\documentclass{beamer}
\usetheme{CambridgeUS}
\usepackage{tikz}
\usetikzlibrary{matrix,arrows,fit,positioning, mindmap, trees}

\usepackage[latin1]{inputenc}
\usefonttheme{professionalfonts}
\usepackage{times}
\usepackage{xmpmulti}
\usepackage{animate}
\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{mathrsfs}  
\usepackage{bussproofs}
\usepackage{tikz}
\usepackage{stmaryrd}
\usepackage{xcolor}
\newcommand{\person}[1]{\textcolor{blue}{#1}}
\newcommand{\highlight}[1]{\textcolor{red}{#1}}
% \newcommand{\example}[1]{\textcolor{blue}{#1}}
\usetikzlibrary{shapes.geometric, positioning}
\graphicspath{ {./images/} }
%\usetheme{Boadilla}
%\usecolortheme{crane}
\title[Formal Languages and Automata Theory]{Formal Languages and Automata Theory}
%\subtitle{I Am Curious}
\author[Sebastian Schlesinger]{Prof. Dr.-Ing. Sebastian Schlesinger}
\institute[HWR Berlin]{Berlin School for Economics and Law}
\date{\today}
\begin{document}
 \begin{frame}
\titlepage
\end{frame}



\begin{frame}
  \frametitle{Outline}
  \tableofcontents
\end{frame}

\begin{frame}{Formal Languages}
Let $\Sigma$ be an alphabet. A \textit{formal language} over $\Sigma$ is a subset of $\Sigma^*$, the set of all strings over $\Sigma$.

\begin{example}
    $\Sigma=\{(,),+,-,*,/,a\}$. Then we can define the correctly formed arithmetic expressions as the formal language $EXPR\subseteq \Sigma^*$. For example, $a+(a*a)$ is in $EXPR$, but $a+*a$ is not.
\end{example}
\end{frame}

\begin{frame}{Grammars}
    A \textit{grammar} is a set of rules for generating strings in a formal language. Formally, it is a 4-tuple $G=(V,\Sigma,P,S)$ such that 
    \begin{itemize}
        \item $V$ is a finite set of variables or non-terminal symbols.
        \item $\Sigma$ is a finite set of terminal symbols. It must hold $V\cap \Sigma = \emptyset$.
        \item $P$ is a finite set of production rules. Formally, $P$ is a finite set of pairs $(V\cup \Sigma)^+\times (V\cup \Sigma)^*$.
        \item $S\in V$ is the start symbol.
    \end{itemize}

    Productions are usually written in the form $u\rightarrow v$ where $u\in (V\cup \Sigma)^+$ and $v\in (V\cup \Sigma)^*$.
\end{frame}

\begin{frame}{Formal Languages}
    Let $u,v\in (V\cup \Sigma)^*$. We define a relation $u\Rightarrow_G v$ (in words: u derives v immediately in G) if $u$ and $v$ have the form
    \vspace{0.5cm}
    $u=xyz$ and $v=xy'z$ for $x,z\in (V\cup \Sigma)^*$ and $y\to y'$ is a production rule in $P$. If $G$ is clear, we may also just write $u\Rightarrow v$.
    \vspace{0.5cm}
    The language generated by a grammar $G$ is $L(G)=\{w\in \Sigma^*\mid S\Rightarrow^*_G w\}$ where $\Rightarrow^*_G$ is the reflexive transitive closure of $\Rightarrow_G$.
    
\end{frame}

\begin{frame}
    \begin{example}
        $G=(\{E,T,F\},\{(,),a,+,*\},P,E)$ where $P=\{E\to T, E\to E+T, T\to F, T\to T*F, F\to (E), F\to a\}$. This yields the language of arithmetic expressions.
    \end{example}
\end{frame}

\begin{frame}
    \begin{example}
        $G=(V,\Sigma,P,S)$ where $V=\{S,B,C\}$, $\Sigma=\{a,b,c\}$, $P=\{S\to aSBC, S\to aBC, CB\to BC, aB\to ab, bB\to bb, bC\to bc, cC\to cc\}$.
        In this language, for instance $S\Rightarrow aSBC\Rightarrow aaSBCBC\Rightarrow aaaBCBCBC\Rightarrow aaaBBCCBC\Rightarrow aaaBBCBCC\Rightarrow aaaBBBCCC\Rightarrow aaabBBCCC\Rightarrow aaabbBCCC\Rightarrow aaabbbCCC\Rightarrow aaaabbbcCC\Rightarrow aaabbbccC\Rightarrow aaabbbccc=a^3b^3c^3$. 

        In total, $L(G)=\{a^nb^nc^n\mid n\geq 1\}$.
    \end{example}
\end{frame}

\begin{frame}{Chomsky Hierarchy}
    \begin{itemize}
        \item Type 0: Recursively enumerable languages - every language without 
        \item Type 1: Context-sensitive languages: if for all productions $w_1\to w_2$ it holds $|w_1|\leq |w_2|$.
        \item Type 2: Context-free languages: if for all productions $w_1\to w_2$ it holds $w_1\in V$ (meaning it is just a variable on the left side).
        \item Type 3: Regular languages: if for all productions $w_1\to w_2$ it holds $w_1\in V$ and $w_2\in \Sigma\cup \Sigma V$, i.e., the right sides are either terminals or a terminal followed by a variable.
    \end{itemize}
    A language $L\subseteq \Sigma^*$ is of type $i$ if there exists a grammar of type $i$ that generates $L$.
\end{frame}

\begin{frame}{$\varepsilon$ rule}
    For type 1,2,3 grammars, because of $|w_1|\leq |w_2|$, the empty word $\varepsilon$ could not be generated. However, if $\varepsilon\in L(G)$ is desired, we allow the rule $S\to\varepsilon$ where $S$ is the start symbol. This is called the $\varepsilon$ rule.
\end{frame}
\begin{frame}
The languages of the Chomsky hierarchy form a strict hierarchy, i.e., there are languages that are of type $i$ but not of type $j$ for $i<j$. For example, the language $L=\{a^nb^n\mid n\geq 1\}$ is context-free but not regular.
\begin{example}
    $L=\{a^nb^n|n\geq 1\}$ is of type 2 but not of type 3. $L=\{a^nb^nc^n|n\geq 1\}$ is of type 1 but not of type 2. $L=H$ is of type 0 but not of type 1. Here, $H$ is the language of the halting problem.
\end{example}
Languages of types 1,2,3 are decidable, i.e., there exists an algorithm that decides whether a given word is in the language or not. For type 0, this is not the case. They are semi-decidable, i.e., there exists an algorithm that decides whether a given word is in the language, but it may not terminate if the word is not in the language. Another term for type 0 languages is recursively enumerable languages.
\end{frame}

\begin{frame}{Word Problem}
    The word problem is the problem of deciding whether a given word $w\in\Sigma^*$ is in a given language, i.e. $w\in L(G)$ or $w\notin L(G)$. For regular languages, this is decidable. For context-free languages, this is also decidable. For context-sensitive languages, this is also decidable. For recursively enumerable languages, this is semi-decidable.
\end{frame}

\begin{frame}{Finite Automata}
    A finite automaton is a 5-tuple $M=(Q,\Sigma,\delta,q_0,F)$ where
    \begin{itemize}
        \item $Q$ is a finite set of states.
        \item $\Sigma$ is the input alphabet. It holds $Q\cap \Sigma=\emptyset$.
        \item $\delta:Q\times \Sigma\to Q$ is the transition function.
        \item $q_0\in Q$ is the start state.
        \item $F\subseteq Q$ is the set of accepting states.
    \end{itemize}
    An automaton can be drawn as a graph.

\end{frame}

\begin{frame}{Accepted Languages}
A language $L\subseteq\Sigma^*$ is accepted by an automaton $M$ if there is a sequence of states $q_0,q_1,\ldots,q_n$ such that $q_0$ is the start state, $q_n$ is an accepting state, i.e., $q_n\in F$, and for all $i=0,\ldots,n-1$, $\delta(q_i,w_{i+1})=q_{i+1}$ where $w_{i+1}$ is the $i+1$-th symbol of the word $w$.
\end{frame}

\begin{frame}{Example}
$Q=\{q_0,q_1,q_2,q_3\},\Sigma=\{a,b\},F=\{q_3\}$, $q_0$ is the start state. $delta(q_0,a)=q_1$, $delta(q_1,b)=q_2$, $delta(q_2,a)=q_3$. This automaton accepts the language $\{ab^na\mid n\geq 0\}$.
\end{frame}
% Slide 1: What are Formal Languages?
% \section{What are Formal Languages?}
% \begin{frame}
%     \frametitle{What are Formal Languages?}
%     \begin{itemize}
%         \item \textbf{Formal language} is a set of strings formed from an alphabet $\Sigma$.
%         \item A language is defined by formal rules, usually grammar or automata.
%         \item Applications: parsing, compilers, coding theory, and more.
%     \end{itemize}
%     \pause
%     \begin{block}{Example}
%         Alphabet: $\Sigma = \{a, b\}$
%         \begin{itemize}
%             \item String: $abba$
%             \item Language: $L = \{ab, ba, abb, bba\}$
%         \end{itemize}
%     \end{block}
% \end{frame}

% % Slide 2: Formal Language Definitions
% \section{Formal Language Definitions}
% \begin{frame}
%     \frametitle{Formal Language Definitions}
%     \begin{itemize}
%         \item \textbf{Alphabet} ($\Sigma$): A non-empty, finite set of symbols.
%         \item \textbf{String} ($w$): A finite sequence of symbols from $\Sigma$.
%         \item \textbf{Language} ($L$): A set of strings over $\Sigma$.
%         \item $\Sigma^*$: The set of all possible strings over $\Sigma$, including the empty string $\epsilon$.
%     \end{itemize}
%     \pause
%     \begin{block}{Operations on Languages}
%         \begin{itemize}
%             \item Union: $L_1 \cup L_2$
%             \item Concatenation: $L_1 L_2 = \{xy \mid x \in L_1, y \in L_2 \}$
%             \item Kleene Star: $L^* = \{ w_1 w_2 \ldots w_n \mid w_i \in L, n \geq 0 \}$
%         \end{itemize}
%     \end{block}
% \end{frame}

% Slide 3: Chomsky Hierarchy of Languages
%\section{Chomsky Hierarchy}
%\begin{frame}
%     \frametitle{Chomsky Hierarchy of Languages}
%     \begin{itemize}
%         \item \textbf{Type 0}: Recursively Enumerable (Turing Machines)
%         \item \textbf{Type 1}: Context-sensitive (Linear-bounded Automata)
%         \item \textbf{Type 2}: Context-free (Pushdown Automata)
%         \item \textbf{Type 3}: Regular (Finite Automata)
%     \end{itemize}
%     \pause
%     \begin{block}{Important Theorem: Language Inclusion}
%         \[
%         \text{Regular} \subset \text{Context-Free} \subset \text{Context-Sensitive} \subset \text{Recursively Enumerable}
%         \]
%     \end{block}
% \end{frame}

% % Slide 4: Regular Languages
% \section{Regular Languages}
% \begin{frame}
%     \frametitle{Regular Languages}
%     \begin{itemize}
%         \item A language is \textbf{regular} if it can be described by a regular expression.
%         \item Can be accepted by a finite automaton (DFA or NFA).
%         \item Closure properties:
%         \begin{itemize}
%             \item Union
%             \item Concatenation
%             \item Kleene Star
%         \end{itemize}
%     \end{itemize}
%     \pause
%     \begin{block}{Theorem: Pumping Lemma for Regular Languages}
%         If $L$ is a regular language, then there exists a constant $p$ such that any string $w \in L$ with $|w| \geq p$ can be split into three parts, $w = xyz$, such that:
%         \begin{itemize}
%             \item $|xy| \leq p$
%             \item $|y| > 0$
%             \item $xy^n z \in L$ for all $n \geq 0$
%         \end{itemize}
%     \end{block}
% \end{frame}

% % Slide 5: Context-Free Languages (CFL)
% \section{Context-Free Languages}
% \begin{frame}
%     \frametitle{Context-Free Languages (CFL)}
%     \begin{itemize}
%         \item Generated by context-free grammars (CFGs).
%         \item Can be accepted by pushdown automata (PDA).
%         \item Closure properties:
%         \begin{itemize}
%             \item Union
%             \item Concatenation
%             \item Kleene Star
%         \end{itemize}
%     \end{itemize}
%     \pause
%     \begin{block}{Theorem: Pumping Lemma for CFLs}
%         If $L$ is a context-free language, there exists a constant $p$ such that any string $w \in L$ with $|w| \geq p$ can be split into five parts, $w = uvxyz$, such that:
%         \begin{itemize}
%             \item $|vxy| \leq p$
%             \item $|vy| > 0$
%             \item $uv^n x y^n z \in L$ for all $n \geq 0$
%         \end{itemize}
%     \end{block}
% \end{frame}

% % Slide 6: Context-Sensitive Languages
% \section{Context-Sensitive Languages}
% \begin{frame}
%     \frametitle{Context-Sensitive Languages}
%     \begin{itemize}
%         \item Generated by context-sensitive grammars.
%         \item Can be accepted by linear-bounded automata (LBA).
%         \item Closure properties:
%         \begin{itemize}
%             \item Union
%             \item Intersection
%             \item Complementation
%         \end{itemize}
%     \end{itemize}
%     \pause
%     \begin{block}{Theorem: Savitch's Theorem}
%         Any context-sensitive language can be decided in deterministic space $O(n^2)$.
%     \end{block}
% \end{frame}

% % Slide 7: Recursively Enumerable Languages
% \section{Recursively Enumerable Languages}
% \begin{frame}
%     \frametitle{Recursively Enumerable Languages}
%     \begin{itemize}
%         \item A language is recursively enumerable if there exists a Turing machine that can enumerate all strings in the language.
%         \item Not all recursively enumerable languages are decidable.
%     \end{itemize}
%     \pause
%     \begin{block}{Theorem: Rice's Theorem}
%         Any non-trivial property of the language recognized by a Turing machine is undecidable.
%     \end{block}
% \end{frame}

% % Slide 8: Important Theorems in Formal Languages
% \section{Important Theorems}
% \begin{frame}
%     \frametitle{Important Theorems in Formal Languages}
%     \begin{itemize}
%         \item \textbf{Myhill-Nerode Theorem}: Characterizes regular languages based on the equivalence of strings.
%         \item \textbf{Kleene's Theorem}: Describes equivalence between regular expressions and finite automata.
%         \item \textbf{Chomsky-Sch√ºtzenberger Theorem}: Every context-free language can be represented using a Dyck language.
%         \item \textbf{Rice's Theorem}: Undecidability of non-trivial properties of Turing machine languages.
%     \end{itemize}
% \end{frame}
\end{document}