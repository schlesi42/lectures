\documentclass{beamer}
\usetheme{CambridgeUS}
\usepackage{tikz}
\usetikzlibrary{matrix,arrows,fit,positioning, mindmap, trees, automata}

\usepackage[latin1]{inputenc}
\usefonttheme{professionalfonts}
\usepackage{times}
\usepackage{xmpmulti}
\usepackage{animate}
\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{mathrsfs}  
\usepackage{bussproofs}

\usepackage{stmaryrd}
\usepackage{xcolor}

\newcommand{\person}[1]{\textcolor{blue}{#1}}
\newcommand{\highlight}[1]{\textcolor{red}{#1}}
% \newcommand{\example}[1]{\textcolor{blue}{#1}}
\usetikzlibrary{shapes.geometric, positioning}
\graphicspath{ {./images/} }
%\usetheme{Boadilla}
%\usecolortheme{crane}
\title[Formal Languages and Automata Theory]{Formal Languages and Automata Theory}
%\subtitle{I Am Curious}
\author[Sebastian Schlesinger]{Prof. Dr.-Ing. Sebastian Schlesinger}
\institute[HWR Berlin]{Berlin School for Economics and Law}
\date{\today}
\begin{document}
 \begin{frame}
\titlepage
\end{frame}




\begin{frame}{Formal Languages}
Let $\Sigma$ be an alphabet. A \textit{formal language} over $\Sigma$ is a subset of $\Sigma^*$, the set of all strings over $\Sigma$.

\begin{example}
    $\Sigma=\{(,),+,-,*,/,a\}$. Then we can define the correctly formed arithmetic expressions as the formal language $EXPR\subseteq \Sigma^*$. For example, $a+(a*a)$ is in $EXPR$, but $a+*a$ is not.
\end{example}
\end{frame}

\begin{frame}{Grammars}
    A \textit{grammar} is a set of rules for generating strings in a formal language. Formally, it is a 4-tuple $G=(V,\Sigma,P,S)$ such that 
    \begin{itemize}
        \item $V$ is a finite set of variables or non-terminal symbols.
        \item $\Sigma$ is a finite set of terminal symbols. It must hold $V\cap \Sigma = \emptyset$.
        \item $P$ is a finite set of production rules. Formally, $P$ is a finite set of pairs $(V\cup \Sigma)^+\times (V\cup \Sigma)^*$.
        \item $S\in V$ is the start symbol.
    \end{itemize}

    Productions are usually written in the form $u\rightarrow v$ where $u\in (V\cup \Sigma)^+$ and $v\in (V\cup \Sigma)^*$.
\end{frame}

\begin{frame}{Formal Languages}
    Let $u,v\in (V\cup \Sigma)^*$. We define a relation $u\Rightarrow_G v$ (in words: u derives v immediately in G) if $u$ and $v$ have the form
    \vspace{0.5cm}
    $u=xyz$ and $v=xy'z$ for $x,z\in (V\cup \Sigma)^*$ and $y\to y'$ is a production rule in $P$. If $G$ is clear, we may also just write $u\Rightarrow v$.
    \vspace{0.5cm}
    The language generated by a grammar $G$ is $L(G)=\{w\in \Sigma^*\mid S\Rightarrow^*_G w\}$ where $\Rightarrow^*_G$ is the reflexive transitive closure of $\Rightarrow_G$.
    
\end{frame}

\begin{frame}
    \begin{example}
        $G=(\{E,T,F\},\{(,),a,+,*\},P,E)$ where $P=\{E\to T, E\to E+T, T\to F, T\to T*F, F\to (E), F\to a\}$. This yields the language of arithmetic expressions.
    \end{example}
\end{frame}

\begin{frame}
    \begin{example}
        $G=(V,\Sigma,P,S)$ where $V=\{S,B,C\}$, $\Sigma=\{a,b,c\}$, $P=\{S\to aSBC, S\to aBC, CB\to BC, aB\to ab, bB\to bb, bC\to bc, cC\to cc\}$.
        In this language, for instance $S\Rightarrow aSBC\Rightarrow aaSBCBC\Rightarrow aaaBCBCBC\Rightarrow aaaBBCCBC\Rightarrow aaaBBCBCC\Rightarrow aaaBBBCCC\Rightarrow aaabBBCCC\Rightarrow aaabbBCCC\Rightarrow aaabbbCCC\Rightarrow aaaabbbcCC\Rightarrow aaabbbccC\Rightarrow aaabbbccc=a^3b^3c^3$. 

        In total, $L(G)=\{a^nb^nc^n\mid n\geq 1\}$.
    \end{example}
\end{frame}

\begin{frame}{Chomsky Hierarchy}
    \begin{itemize}
        \item Type 0: Recursively enumerable languages - every language without restrictions on the production rules.
        \item Type 1: Context-sensitive languages: if for all productions $w_1\to w_2$ it holds $|w_1|\leq |w_2|$.
        \item Type 2: Context-free languages: if for all productions $w_1\to w_2$ it holds $w_1\in V$ (meaning it is just a variable on the left side).
        \item Type 3: Regular languages: if for all productions $w_1\to w_2$ it holds $w_1\in V$ and $w_2\in \Sigma\cup \Sigma V$, i.e., the right sides are either terminals or a terminal followed by a variable.
    \end{itemize}
    A language $L\subseteq \Sigma^*$ is of type $i$ if there exists a grammar of type $i$ that generates $L$.
\end{frame}

\begin{frame}{$\varepsilon$ rule}
    For type 1,2,3 grammars, because of $|w_1|\leq |w_2|$, the empty word $\varepsilon$ could not be generated. However, if $\varepsilon\in L(G)$ is desired, we allow the rule $S\to\varepsilon$ where $S$ is the start symbol. This is called the $\varepsilon$ rule.
\end{frame}
\begin{frame}
The languages of the Chomsky hierarchy form a strict hierarchy, i.e., there are languages that are of type $i$ but not of type $j$ for $i<j$. For example, the language $L=\{a^nb^n\mid n\geq 1\}$ is context-free but not regular.
\begin{example}
    $L=\{a^nb^n|n\geq 1\}$ is of type 2 but not of type 3. $L=\{a^nb^nc^n|n\geq 1\}$ is of type 1 but not of type 2. $L=H$ is of type 0 but not of type 1. Here, $H$ is the language of the halting problem.
\end{example}
Languages of types 1,2,3 are decidable, i.e., there exists an algorithm that decides whether a given word is in the language or not. For type 0, this is not the case. They are semi-decidable, i.e., there exists an algorithm that decides whether a given word is in the language, but it may not terminate if the word is not in the language. Another term for type 0 languages is recursively enumerable languages.
\end{frame}

\begin{frame}{Word Problem}
    The word problem is the problem of deciding whether a given word $w\in\Sigma^*$ is in a given language, i.e. $w\in L(G)$ or $w\notin L(G)$. For regular languages, this is decidable. For context-free languages, this is also decidable. For context-sensitive languages, this is also decidable. For recursively enumerable languages, this is semi-decidable.
\end{frame}

\begin{frame}{Deterministic Finite Automata}
    A deterministic finite automaton (DFA) is a 5-tuple $M=(Q,\Sigma,\delta,q_0,F)$ where
    \begin{itemize}
        \item $Q$ is a finite set of states.
        \item $\Sigma$ is the input alphabet. It holds $Q\cap \Sigma=\emptyset$.
        \item $\delta:Q\times \Sigma\to Q$ is the transition function.
        \item $q_0\in Q$ is the start state.
        \item $F\subseteq Q$ is the set of accepting states.
    \end{itemize}
    An automaton can be drawn as a graph.

\end{frame}

\begin{frame}{DFA as Graph}
    \begin{itemize}
        \item Each state $q\in Q$ is represented as a node.
        \item The start state $q_0$ has an incoming arrow from nowhere.
        \item Each accepting state $q\in F$ is represented as a double circle.
        \item For each transition $\delta(q,a)=p$, there is a directed edge from node $q$ to node $p$ labeled with the symbol $a$.
    \end{itemize}
    Note that $\delta$ is a total function, i.e., for each state $q\in Q$ and each symbol $a\in \Sigma$, there is exactly one transition defined.
\end{frame}

% \begin{frame}{DFA Example}
%     \begin{figure}
%         \centering
%         \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
%            \node[state,initial] (q_0)   {$q_0$}; 
%            \node[state] (q_1) [right=of q_0] {$q_1$}; 
%            \node[state,accepting] (q_2) [right=of q_1] {$q_2$}; 
%             \path[->] 
%             (q_0) edge  node {a} (q_1)
%             (q_1) edge  node {b} (q_2)
%             (q_2) edge [loop above] node {a,b} ();
%         \end{tikzpicture}
%         \caption{A simple DFA}
%     \end{figure}
% \end{frame}

\begin{frame}{Non-deterministic Finite Automata}
    A non-deterministic finite automaton (NFA) is a 5-tuple $M=(Q,\Sigma,\delta,S_0,F)$ where
    \begin{itemize}
        \item $Q$ is a finite set of states.
        \item $\Sigma$ is the input alphabet. It holds $Q\cap \Sigma=\emptyset$.
        \item $\delta:Q\times (\Sigma\cup\{\varepsilon\})\to 2^Q$ is the transition function.
        \item $S_0\subseteq Q$ is the set of start states.
        \item $F\subseteq   Q$ is the set of accepting states.
    \end{itemize}
    An NFA can also be drawn as a graph, similar to a DFA. Since $\delta$ a function to sets of states, there may be multiple transitions for the same state and input symbol and there may also be no transition for a given state and input symbol.
\end{frame}



\begin{frame}{Accepted Languages}
For a DFA $M=(Q,\Sigma,\delta,q_0,F)$, we define $\hat{\delta}:Q\times \Sigma^*\to Q$ as follows:
\begin{itemize}
    \item $\hat{\delta}(q,\varepsilon)=q$ for all $q\in Q$.
    \item $\hat{\delta}(q,xa)=\delta(\hat{\delta}(q,x),a)$ for all $q\in Q$, $x\in \Sigma^*$, $a\in \Sigma$.
\end{itemize}
The language accepted by $M$ is $T(M)=\{w\in \Sigma^*\mid \hat{\delta}(q_0,w)\in F\}$.
Similarly, for an NFA $M=(Q,\Sigma,\delta,q_0,F)$, we define $\hat{\delta}:Q\times \Sigma^*\to 2^Q$ as follows:
\begin{itemize}
    \item $\hat{\delta}(q,\varepsilon)=\{q\}$ for all $q\in Q$.
    \item   $\hat{\delta}(q,xa)=\bigcup_{p\in \hat{\delta}(q,x)}\delta(p,a)$ for all $q\in Q$, $x\in \Sigma^*$, $a\in \Sigma$.
    
\end{itemize}
The language accepted by $M$ is $T(M)=\{w\in \Sigma^*\mid q_0\in S_0,\hat{\delta}(q_0,w)\cap F\neq \emptyset\}$.
\end{frame}

\begin{frame}{NFA to DFA}
    For every NFA $M=(Q,\Sigma,\delta,S_0,F)$, there exists a DFA $M'=(Q',\Sigma,\delta',q_0',F')$ such that $T(M)=T(M')$. The construction is as follows:
    \begin{itemize}
        \item $Q'=2^Q$
        \item $q_0'=S_0$
        \item $\delta':Q'\times \Sigma\to Q'$ defined as $\delta'(S,a)=\bigcup_{q\in S}\delta(q,a)$ for all $S\in Q'$, $a\in \Sigma$.
        \item $F'=\{S\in Q' \mid S\cap F\neq \emptyset\}$
    \end{itemize}
\end{frame}

% \begin{frame}{Example for NFA to DFA}
%     Consider the following NFA:
% \begin{tikzpicture}[node distance=2.2cm, on grid, auto]
%   % States
%   \node[state, initial]           (q0) {$q_0$};
%   \node[state]                    (q1) [above right=of q0] {$q_1$};
%   \node[state]                    (q2) [below right=of q0] {$q_2$};
%   \node[state, accepting]         (q3) [right=4.5cm of q0] {$q_3$};
%   \node[state]                    (q4) [right=of q2] {$q_4$};

%   % Transitions
%   \path[->]
%     (q0) edge node {$\varepsilon$} (q1)
%     (q0) edge node [swap] {$\varepsilon$} (q2)
%     (q1) edge node {$a$} (q3)
%     (q2) edge node {$a$} (q4)
%     (q4) edge node {$b$} (q3);
% \end{tikzpicture}
% \end{frame}

% \begin{frame}{Example for NFA to DFA (cont.)}
%     The equivalent DFA is:
% \begin{tikzpicture}[node distance=2.6cm, on grid, auto]
%   % DFA states (sets)
%   \node[state, initial]                   (S0) {$\{q_0,q_1,q_2\}$};
%   \node[state, accepting]                 (S1) [right=of S0] {$\{q_3,q_4\}$};
%   \node[state, accepting]                 (S2) [right=of S1] {$\{q_3\}$};
%   \node[state]                            (Sd) [below=of S1] {$\emptyset$};

%   % Transitions
%   \path[->]
%     (S0) edge node {$a$} (S1)
%     (S0) edge node [swap] {$b$} (Sd)

%     (S1) edge node {$b$} (S2)
%     (S1) edge[bend left] node {$a$} (Sd)

%     (S2) edge[bend left] node {$a$} (Sd)
%     (S2) edge[bend left] node {$b$} (Sd)

%     (Sd) edge[loop below] node {$a,b$} (Sd);
% \end{tikzpicture}
% \end{frame}

\begin{frame}{Minimize a DFA}
    For every DFA $M=(Q,\Sigma,\delta,q_0,F)$, there exists a unique (up to isomorphism) minimal DFA $M'=(Q',\Sigma,\delta',q_0',F')$ such that $T(M)=T(M')$ and $|Q'|\leq |Q|$. The construction is as follows:
    \begin{itemize}
        \item Remove unreachable states from $Q$.
        \item Define an equivalence relation $\sim$ on $Q$ such that $p\sim q$ if for all $w\in \Sigma^*$, $\hat{\delta}(p,w)\in F$ if and only if $\hat{\delta}(q,w)\in F$.
        \item The states of $M'$ are the equivalence classes of $\sim$.
        \item The start state of $M'$ is the equivalence class of $q_0$.
        \item The accepting states of $M'$ are the equivalence classes that contain at least one accepting state of $M$.
        \item The transition function $\delta'$ is defined as $\delta'([q],a)=[\delta(q,a)]$ for all equivalence classes $[q]$ and all $a\in \Sigma$.
    \end{itemize}
\end{frame}
\begin{frame}{Myhill-Nerode Theorem}
    A language $L\subseteq \Sigma^*$ is regular if and only if the equivalence relation $\equiv_L$ defined as $x\equiv_L y$ if for all $z\in \Sigma^*$, $xz\in L$ if and only if $yz\in L$ has a finite number of equivalence classes.
    
    This theorem is used to construct the minimal DFA for a regular language $L$. The states of the minimal DFA are the equivalence classes of $\equiv_L$.
\end{frame} 

\begin{frame}{Algorithm for Minimizing a DFA}
    \begin{itemize}
        \item Create a table with all pairs of states $(p,q)$ where $p,q\in Q$ and $p\neq q$.
        \item Mark all pairs $(p,q)$ where $p\in F$ and $q\notin F$ or $p\notin F$ and $q\in F$.
        \item Repeat until no new pairs are marked:
        \begin{itemize}
            \item For each unmarked pair $(p,q)$, for each $a\in \Sigma$, check the pair $(\delta(p,a),\delta(q,a))$. If this pair is marked, mark $(p,q)$.
        \end{itemize}
        \item The unmarked pairs represent equivalent states. Merge them to form the states of the minimal DFA.
    \end{itemize}
\end{frame}



\begin{frame}{Pumping Lemma for Regular Languages}
    If $L$ is a regular language, then there exists a constant $p$ (the pumping length) such that any string $w\in L$ with $|w|\geq p$ can be split into three parts, $w=xyz$, such that:
    \begin{itemize}
        \item $|xy|\leq p$
        \item $|y|>0$
        \item $xy^n z\in L$ for all $n\geq 0$
    \end{itemize}
    This can be used to prove that a language is not regular.

    \end{frame}

\begin{frame}{Pushdown Automata}
    A pushdown automaton (PDA) is a 7-tuple $M=(Q,\Sigma,\Gamma,\delta,q_0,Z_0,F)$ where
    \begin{itemize}
        \item $Q$ is a finite set of states.
        \item $\Sigma$ is the input alphabet. It holds $Q\cap \Sigma=\emptyset$.
        \item $\Gamma$ is the stack alphabet. It holds $Q\cap \Gamma=\emptyset$ and $\Sigma\cap \Gamma=\emptyset$.
        \item $\delta:Q\times (\Sigma\cup\{\varepsilon\})\times \Gamma\to 2^{Q\times \Gamma^*}$ is the transition function.
        \item $q_0\in Q$ is the start state.
        \item $Z_0\in \Gamma$ is the initial stack symbol.
        \item $F\subseteq Q$ is the set of accepting states.
    \end{itemize}
    \end{frame}

\begin{frame}{PDA Configurations}
    A configuration of a PDA is a triple $(q,w,\gamma)$ where $q\in Q$ is the current state, $w\in \Sigma^*$ is the remaining input, and $\gamma\in \Gamma^*$ is the current stack content (with the top of the stack being the leftmost symbol).
    
    The PDA can make a transition from configuration $(q,aw,\gamma Z)$ to $(p,w,\beta \gamma)$ if $(p,\beta)\in \delta(q,a,Z)$ for $a\in \Sigma\cup\{\varepsilon\}$, $Z\in \Gamma$, and $\beta\in \Gamma^*$.
    
    The PDA accepts an input string $w$ if there exists a sequence of transitions starting from $(q_0,w,Z_0)$ that leads to a configuration $(q,\varepsilon,\gamma)$ where $q\in F$.
\end{frame}
\begin{frame}{Turing Machines}
    A Turing machine (TM) is a 7-tuple $M=(Q,\Sigma,\Gamma,\delta,q_0,B,F)$ where
    \begin{itemize}
        \item $Q$ is a finite set of states.
        \item $\Sigma$ is the input alphabet. It holds $Q\cap \Sigma=\emptyset$.
        \item $\Gamma$ is the tape alphabet. It holds $Q\cap \Gamma=\emptyset$ and $\Sigma\subseteq \Gamma$.
        \item $\delta:Q\times \Gamma\to Q\times \Gamma\times \{L,R\}$ is the transition function.
        \item $q_0\in Q$ is the start state.
        \item $B\in \Gamma$ is the blank symbol.
        \item $F\subseteq Q$ is the set of accepting states.
    \end{itemize}
\end{frame}

\begin{frame}{TM Configurations}
    A configuration of a TM is a triple $(q,w,a\gamma)$ where $q\in Q$ is the current state, $w\in \Gamma^*$ is the content of the tape to the left of the head, and $a\gamma\in \Gamma^*$ is the content of the tape from the head position to the right (with $a$ being the symbol under the head).
    
    The TM can make a transition from configuration $(q,w,a\gamma)$ to $(p,w',b\gamma')$ if $\delta(q,a)=(p,b,D)$ where $D\in \{L,R\}$, and
    \begin{itemize}
        \item If $D=R$, then $w'=wb$ and $\gamma'=\gamma$.
        \item If $D=L$, then $w'$ is $w$ without its last symbol (if $w$ is not empty) and $\gamma'=c b \gamma$ where $c$ is the last symbol of $w$ (or $B$ if $w$ is empty).
    \end{itemize}
    
    The TM accepts an input string $w$ if there exists a sequence of transitions starting from $(q_0,\varepsilon,w)$ that leads to a configuration $(q,\alpha,\beta)$ where $q\in F$.

\end{frame}

\begin{frame}{Linear Bounded Automata}
    A linear bounded automaton (LBA) is a Turing machine with the restriction that the tape head cannot move beyond the portion of the tape that contains the input string. In other words, the tape is bounded by the length of the input.
    
    Formally, an LBA is a TM $M=(Q,\Sigma,\Gamma,\delta,q_0,B,F)$ where the tape head is not allowed to move left of the leftmost symbol of the input or right of the rightmost symbol of the input.
    
    LBAs recognize context-sensitive languages.
\end{frame}

\begin{frame}{Correspondence between Grammars and Automata}
    \begin{itemize}
        \item Regular languages (Type 3) can be recognized by DFAs and NFAs.
        \item Context-free languages (Type 2) can be recognized by PDAs.
        \item Context-sensitive languages (Type 1) can be recognized by LBAs.
        \item Recursively enumerable languages (Type 0) can be recognized by TMs.
    \end{itemize}
\end{frame}


% Slide 1: What are Formal Languages?
% \section{What are Formal Languages?}
% \begin{frame}
%     \frametitle{What are Formal Languages?}
%     \begin{itemize}
%         \item \textbf{Formal language} is a set of strings formed from an alphabet $\Sigma$.
%         \item A language is defined by formal rules, usually grammar or automata.
%         \item Applications: parsing, compilers, coding theory, and more.
%     \end{itemize}
%     \pause
%     \begin{block}{Example}
%         Alphabet: $\Sigma = \{a, b\}$
%         \begin{itemize}
%             \item String: $abba$
%             \item Language: $L = \{ab, ba, abb, bba\}$
%         \end{itemize}
%     \end{block}
% \end{frame}

% % Slide 2: Formal Language Definitions
% \section{Formal Language Definitions}
% \begin{frame}
%     \frametitle{Formal Language Definitions}
%     \begin{itemize}
%         \item \textbf{Alphabet} ($\Sigma$): A non-empty, finite set of symbols.
%         \item \textbf{String} ($w$): A finite sequence of symbols from $\Sigma$.
%         \item \textbf{Language} ($L$): A set of strings over $\Sigma$.
%         \item $\Sigma^*$: The set of all possible strings over $\Sigma$, including the empty string $\epsilon$.
%     \end{itemize}
%     \pause
%     \begin{block}{Operations on Languages}
%         \begin{itemize}
%             \item Union: $L_1 \cup L_2$
%             \item Concatenation: $L_1 L_2 = \{xy \mid x \in L_1, y \in L_2 \}$
%             \item Kleene Star: $L^* = \{ w_1 w_2 \ldots w_n \mid w_i \in L, n \geq 0 \}$
%         \end{itemize}
%     \end{block}
% \end{frame}

% Slide 3: Chomsky Hierarchy of Languages
%\section{Chomsky Hierarchy}
%\begin{frame}
%     \frametitle{Chomsky Hierarchy of Languages}
%     \begin{itemize}
%         \item \textbf{Type 0}: Recursively Enumerable (Turing Machines)
%         \item \textbf{Type 1}: Context-sensitive (Linear-bounded Automata)
%         \item \textbf{Type 2}: Context-free (Pushdown Automata)
%         \item \textbf{Type 3}: Regular (Finite Automata)
%     \end{itemize}
%     \pause
%     \begin{block}{Important Theorem: Language Inclusion}
%         \[
%         \text{Regular} \subset \text{Context-Free} \subset \text{Context-Sensitive} \subset \text{Recursively Enumerable}
%         \]
%     \end{block}
% \end{frame}

% % Slide 4: Regular Languages
% \section{Regular Languages}
% \begin{frame}
%     \frametitle{Regular Languages}
%     \begin{itemize}
%         \item A language is \textbf{regular} if it can be described by a regular expression.
%         \item Can be accepted by a finite automaton (DFA or NFA).
%         \item Closure properties:
%         \begin{itemize}
%             \item Union
%             \item Concatenation
%             \item Kleene Star
%         \end{itemize}
%     \end{itemize}
%     \pause
%     \begin{block}{Theorem: Pumping Lemma for Regular Languages}
%         If $L$ is a regular language, then there exists a constant $p$ such that any string $w \in L$ with $|w| \geq p$ can be split into three parts, $w = xyz$, such that:
%         \begin{itemize}
%             \item $|xy| \leq p$
%             \item $|y| > 0$
%             \item $xy^n z \in L$ for all $n \geq 0$
%         \end{itemize}
%     \end{block}
% \end{frame}

% % Slide 5: Context-Free Languages (CFL)
% \section{Context-Free Languages}
% \begin{frame}
%     \frametitle{Context-Free Languages (CFL)}
%     \begin{itemize}
%         \item Generated by context-free grammars (CFGs).
%         \item Can be accepted by pushdown automata (PDA).
%         \item Closure properties:
%         \begin{itemize}
%             \item Union
%             \item Concatenation
%             \item Kleene Star
%         \end{itemize}
%     \end{itemize}
%     \pause
%     \begin{block}{Theorem: Pumping Lemma for CFLs}
%         If $L$ is a context-free language, there exists a constant $p$ such that any string $w \in L$ with $|w| \geq p$ can be split into five parts, $w = uvxyz$, such that:
%         \begin{itemize}
%             \item $|vxy| \leq p$
%             \item $|vy| > 0$
%             \item $uv^n x y^n z \in L$ for all $n \geq 0$
%         \end{itemize}
%     \end{block}
% \end{frame}

% % Slide 6: Context-Sensitive Languages
% \section{Context-Sensitive Languages}
% \begin{frame}
%     \frametitle{Context-Sensitive Languages}
%     \begin{itemize}
%         \item Generated by context-sensitive grammars.
%         \item Can be accepted by linear-bounded automata (LBA).
%         \item Closure properties:
%         \begin{itemize}
%             \item Union
%             \item Intersection
%             \item Complementation
%         \end{itemize}
%     \end{itemize}
%     \pause
%     \begin{block}{Theorem: Savitch's Theorem}
%         Any context-sensitive language can be decided in deterministic space $O(n^2)$.
%     \end{block}
% \end{frame}

% % Slide 7: Recursively Enumerable Languages
% \section{Recursively Enumerable Languages}
% \begin{frame}
%     \frametitle{Recursively Enumerable Languages}
%     \begin{itemize}
%         \item A language is recursively enumerable if there exists a Turing machine that can enumerate all strings in the language.
%         \item Not all recursively enumerable languages are decidable.
%     \end{itemize}
%     \pause
%     \begin{block}{Theorem: Rice's Theorem}
%         Any non-trivial property of the language recognized by a Turing machine is undecidable.
%     \end{block}
% \end{frame}

% % Slide 8: Important Theorems in Formal Languages
% \section{Important Theorems}
% \begin{frame}
%     \frametitle{Important Theorems in Formal Languages}
%     \begin{itemize}
%         \item \textbf{Myhill-Nerode Theorem}: Characterizes regular languages based on the equivalence of strings.
%         \item \textbf{Kleene's Theorem}: Describes equivalence between regular expressions and finite automata.
%         \item \textbf{Chomsky-Schützenberger Theorem}: Every context-free language can be represented using a Dyck language.
%         \item \textbf{Rice's Theorem}: Undecidability of non-trivial properties of Turing machine languages.
%     \end{itemize}
% \end{frame}
\end{document}